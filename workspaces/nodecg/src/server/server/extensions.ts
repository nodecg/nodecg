import * as path from "node:path";

import * as Sentry from "@sentry/node";
import { Effect } from "effect";
import semver from "semver";

import { stringifyError } from "../../shared/utils/errors.js";
import type { NodeCG } from "../../types/nodecg.js";
import type { RootNS } from "../../types/socket-protocol.js";
import { serverApiFactory } from "../api.server.js";
import { sentryEnabled } from "../config/index.js";
import { createLogger } from "../logger/index.js";
import type { Replicator } from "../replicant/replicator.js";
import { BundleManager } from "./bundle-manager.js";

const log = createLogger("extensions");

export interface ExtensionEventMap {
	login: (user: Express.Request["user"]) => void;
	logout: (user: Express.Request["user"]) => void;
	extensionsLoaded: () => void;
	serverStarted: () => void;
	serverStopping: () => void;
}

export const createExtensionManager = Effect.fn("createExtensionManager")(
	function* (io: RootNS, replicator: Replicator, mount: NodeCG.Middleware) {
		const bundleManager = yield* BundleManager;
		const extensions: Record<string, unknown> = {};
		const apiInstances = new Set<
			InstanceType<ReturnType<typeof serverApiFactory>>
		>();

		const satisfiedDepNames = new WeakMap<NodeCG.Bundle, string[]>();

		log.trace("Starting extension mounting");
		const ExtensionApi = serverApiFactory(io, replicator, extensions, mount);

		// Prevent us from messing with other listeners of this event
		const allBundles = [...bundleManager.all()];

		// Track which bundles we know are fully loaded (extension and all)
		const fullyLoaded: NodeCG.Bundle[] = [];

		while (allBundles.length > 0) {
			const startLen = allBundles.length;
			for (let i = 0; i < startLen; i++) {
				const bundle = allBundles[i];
				if (!bundle) {
					continue;
				}

				// If this bundle has no dependencies, load it and remove it from the list
				if (!bundle.bundleDependencies) {
					log.debug("Bundle %s has no dependencies", bundle.name);

					if (bundle.hasExtension) {
						yield* loadExtension(bundle);
					}

					fullyLoaded.push(bundle);
					allBundles.splice(i, 1);
					break;
				}

				// If this bundle has dependencies, and all of them are satisfied, load it and remove it from the list
				if (bundleDepsSatisfied(bundle, fullyLoaded)) {
					log.debug(
						"Bundle %s has extension with satisfied dependencies",
						bundle.name,
					);

					if (bundle.hasExtension) {
						yield* loadExtension(bundle);
					}

					fullyLoaded.push(bundle);
					allBundles.splice(i, 1);
					break;
				}
			}

			const endLen = allBundles.length;
			if (startLen === endLen) {
				// Any bundles left over must have had unsatisfied dependencies.
				// Print a warning about each bundle, and what its unsatisfied deps were.
				// Then, unload the bundle.
				for (const bundle of allBundles) {
					const unsatisfiedDeps = [];

					for (const dep in bundle.bundleDependencies) {
						if (!{}.hasOwnProperty.call(bundle.bundleDependencies, dep)) {
							continue;
						}

						const satisfied = satisfiedDepNames.get(bundle);
						if (satisfied?.includes(dep)) {
							continue;
						}

						unsatisfiedDeps.push(`${dep}@${bundle.bundleDependencies[dep]}`);
					}

					log.error(
						'Bundle "%s" can not be loaded, as it has unsatisfied dependencies:\n',
						bundle.name,
						unsatisfiedDeps.join(", "),
					);
					yield* bundleManager.remove(bundle.name);
				}

				log.error(
					"%d bundle(s) can not be loaded because they have unsatisfied dependencies",
					endLen,
				);
				break;
			}
		}

		log.trace("Completed extension mounting");

		function emitToAllInstances<K extends keyof ExtensionEventMap>(
			eventName: K,
			...params: Parameters<ExtensionEventMap[K]>
		) {
			for (const instance of apiInstances) {
				instance.emit(eventName, ...params);
			}
		}

		function loadExtension(bundle: NodeCG.Bundle) {
			return Effect.gen(function* () {
				const extPath = path.join(bundle.dir, "extension");
				// TODO: convert to Effect.try
				try {
					const requireFunc = process.env.NODECG_TEST
						? require
						: module.require;
					let mod = requireFunc(extPath);

					// If the extension has been generated by Babel/TypeScript and exported with "export default".
					if (mod.__esModule) {
						mod = mod.default;
					}

					const apiInstance = new ExtensionApi(bundle);
					apiInstances.add(apiInstance);
					const extension = mod(apiInstance);
					log.info("Mounted %s extension", bundle.name);
					extensions[bundle.name] = extension;
				} catch (err: unknown) {
					yield* bundleManager.remove(bundle.name);
					log.warn(
						"Failed to mount %s extension:\n",
						bundle.name,
						stringifyError(err),
					);
					if (sentryEnabled) {
						(err as Error).message =
							`Failed to mount ${bundle.name} extension: ${
								(err as Error)?.message ?? err
							}`;
						Sentry.captureException(err);
					}
				}
			});
		}

		function bundleDepsSatisfied(
			bundle: NodeCG.Bundle,
			loadedBundles: NodeCG.Bundle[],
		): boolean {
			const deps = bundle.bundleDependencies;
			if (!deps) {
				return true;
			}

			const unsatisfiedDepNames = Object.keys(deps);
			const arr = satisfiedDepNames.get(bundle)?.slice(0) ?? [];

			loadedBundles.forEach((loadedBundle) => {
				// Find out if this loaded bundle is one of the dependencies of the bundle in question.
				// If so, check if the version loaded satisfies the dependency.
				const index = unsatisfiedDepNames.indexOf(loadedBundle.name);
				if (index > -1) {
					if (
						semver.satisfies(loadedBundle.version, deps[loadedBundle.name]!)
					) {
						arr.push(loadedBundle.name);
						unsatisfiedDepNames.splice(index, 1);
					}
				}
			});

			satisfiedDepNames.set(bundle, arr);
			return unsatisfiedDepNames.length === 0;
		}

		return {
			emitToAllInstances,
			getExtensions: () => ({ ...extensions }),
		};
	},
);
