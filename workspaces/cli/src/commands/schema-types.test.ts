import { EventEmitter } from "node:events";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

import { beforeEach, expect, it, vi } from "vitest";

import { createMockProgram, MockCommand } from "../../test/mocks/program.js";
import { setupTmpDir } from "../../test/tmp-dir.js";
import { schemaTypesCommand } from "./schema-types.js";

const dirname = path.dirname(fileURLToPath(import.meta.url));

let program: MockCommand;

beforeEach(() => {
	// Set up environment.
	const tempFolder = setupTmpDir();
	process.chdir(tempFolder);
	fs.writeFileSync("package.json", JSON.stringify({ name: "nodecg" }));

	// Copy fixtures.
	fs.cpSync(path.resolve(dirname, "../../test/fixtures/"), "./", {
		recursive: true,
	});

	// Build program.
	program = createMockProgram();
	schemaTypesCommand(program as any);
});

it("should successfully create d.ts files from the replicant schemas and create an index.d.ts file", async () => {
	process.chdir("bundles/schema-types");

	/*
	 * Commander has no return values for command invocations.
	 * This means that if your command returns a promise (or is otherwise async),
	 * there is no way to get a reference to that promise to await it.
	 * The command is just invoked by a dispatched event, with no
	 * way to access the return value of your command's action.
	 *
	 * This makes testing async actions very challenging.
	 *
	 * Our current solution is to hack custom events onto the process global.
	 * It's gross, but whatever. It works for now.
	 */
	await Promise.all([
		program.runWith("schema-types"),
		waitForEvent(process, "schema-types-done"),
	]);

	const outputPath = "./src/types/schemas/example.d.ts";
	expect(fs.existsSync(outputPath)).toBe(true);

	expect(fs.readFileSync(outputPath, "utf8")).toMatchInlineSnapshot(`
		"/* prettier-ignore */
		/* eslint-disable */
		/**
		 * This file was automatically generated by json-schema-to-typescript.
		 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
		 * and run json-schema-to-typescript to regenerate this file.
		 */

		export interface Example {
			ip: string;
			port: number;
			password: string;
			status: 'connected' | 'connecting' | 'disconnected' | 'error';
		}
		"
	`);
});

it("should print an error when the target bundle does not have a schemas dir", async () => {
	process.chdir("bundles/uninstall-test");
	const spy = vi.spyOn(console, "error");
	await program.runWith("schema-types");
	expect(spy.mock.calls[0]).toMatchInlineSnapshot(
		`
		[
		  "Error: Input directory does not exist",
		]
	`,
	);
	spy.mockRestore();
});

it("should successfully compile the config schema", async () => {
	process.chdir("bundles/config-schema");
	fs.mkdirSync("empty-dir");

	await Promise.all([
		program.runWith("schema-types empty-dir"),
		waitForEvent(process, "schema-types-done"),
	]);

	const outputPath = "./src/types/schemas/configschema.d.ts";
	expect(fs.existsSync(outputPath)).toBe(true);

	expect(fs.readFileSync(outputPath, "utf8")).toMatchInlineSnapshot(`
		"/* prettier-ignore */
		/* eslint-disable */
		/**
		 * This file was automatically generated by json-schema-to-typescript.
		 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
		 * and run json-schema-to-typescript to regenerate this file.
		 */

		export interface Configschema {
			username?: string;
			value?: number;
			nodefault?: string;
			[k: string]: unknown;
		}
		"
	`);
});

async function waitForEvent(emitter: EventEmitter, eventName: string) {
	return new Promise<void>((resolve) => {
		emitter.on(eventName, () => {
			resolve();
		});
	});
}
